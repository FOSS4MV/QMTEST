$catalog QMTest global
class QMTest

    shared private passes, failures, errors, ignores, skips
    private lPasses, lFailures, lErrors, lIgnores, lSkips, ignore, skip
    private beforeClass, afterClass, beforeMethod, afterMethod, tests, ignored, skipped, exceptions
    
    public sub create.object()
        if unassigned(passes) then passes = 0
        if unassigned(failures) then failures = 0
        if unassigned(errors) then errors = 0
        if unassigned(ignores) then ignores = 0
        if unassigned(skips) then skips = 0
        lPasses = 0
        lFailures = 0
        lErrors = 0
        lIgnores = 0
        lSkips = 0
        beforeClass = ''
        afterClass = ''
        beforeMethod = ''
        afterMethod = ''
        tests = ''
        ignored = ''
        skipped = ''
        exceptions = ''
    end
    
    public sub run(className, obj)
        try
            me->parseAnnotations(className)
            
            *
            * Check for @BeforeClass annotation and run once before
            * all the test methods are run.
            *
            if (beforeClass # '') then obj->(beforeClass)()
                              
            *
            * Loop through the tests, run the before method (if one defined),
            * run the test method, the run the after method (if one defined).
            * Wrap the test method itself in a try/catch block to catch 
            * assertions that fail.  Allow all non-assertion errors to be
            * logged as errors and end the run of this test class.
            * 
            testCount = 0
            for each test in tests
                testCount += 1
                method = test[':', 1, 1]
                crt className : ":" : method : " -> " :
                ignore = ignored<testCount>
                skip = skipped<testCount>
                exception = exceptions<testCount>
                if (ignore) then
                    lIgnores += 1
                    crt "Ignored!"
                    continue
                end
                if (skip) then
                    lSkips += 1
                    crt "Skipped!"
                    continue
                end
                try
                    if (beforeMethod # '') then obj->(beforeMethod)()
                    obj->(method)()
                    if (afterMethod # '') then obj->(afterMethod)()
                    lPasses += 1
                    crt "Passed!"
                catch AssertionError
                    lFailures += 1
                    crt "Failed!"
                    crt @EXCEPTION : " -> " : @EXCEPTION.DATA
                catch SYS$ANY
                    if (exception # '') then
                        if (@EXCEPTION = upcase(exception)) then
                            if (afterMethod # '') then obj->(afterMethod)()
                            lPasses += 1
                            crt "Passed! Exception=" : exception : " expected!"
                            continue
                        end
                    end
                    if assigned(@EXCEPTION.DATA) then
                        throw @EXCEPTION, @EXCEPTION.DATA
                    end else
                        throw @EXCEPTION
                    end
                end
            next test
            
            *
            * Check for @AfterClass annotation and run once after
            * all tests have completed.
            *
            if (afterClass # '') then obj->(afterClass)()
            
        catch SYS$ANY
            lErrors += 1
            crt "Error! (" : @EXCEPTION : ")"
            if assigned(@EXCEPTION.DATA) then crt @EXCEPTION.DATA
            
        end
        crt className : ": " :
        crt lPasses : " passes/ " :
        crt lFailures : " failures/ " :
        crt lErrors : " errors/ " :
        crt lIgnores : " ignored/ " :
        crt lSkips : " skipped"
        crt
        passes += lPasses
        failures += lFailures
        errors += lErrors
        ignores += lIgnores
        skips += lSkips
    end
    
    public sub runSub(subName)
        
        try
            crt subName : ": " :
            me->parseAnnotations(subName)
            test = tests<1>
            if (ignores<1>) then throw "Ignore"
            if (skips<1>) then throw "Skip"
            *
            * @Test:subName:sub/func:param1,param2,...:expected
            *
            * subName is the name of the subroutine/function as cataloged
            * sub/func is the type of call (subroutine or function)
            * param1... are the actual test parameter values to be used
            * expected is the result return if type if func[tion]
            *
            callName = test[':', 1, 1]
            callType = test[':', 2, 1]
            callParams = test[':', 3, 1]
            expected = test[':', 4, 1]
            paramCount = dcount(callParams, ',')
            params = ''
            for p = 1 to paramCount
                params<p> = callParams[',', p, 1]
            next p
            if (callType[1,3] = "sub") then
                begin case
                    CASE (paramCount = 0)
                        call @callName
                    case (paramCount = 1)
                        call @callName(params<1>)
                    case (paramCount = 2)
                        call @callName(params<1>, params<2>)
                    case (paramCount = 3)
                        call @callName(params<1>, params<2>, params<3>)
                    case (paramCount = 4)
                        call @callName(params<1>, params<2>, params<3>, params<4>)
                    case (paramCount = 5)
                        call @callName(params<1>, params<2>, params<3>, params<4>, params<5>)
                end case
            end else
                begin case
                    case (paramCount = 0)
                        call @callName(retval)
                    case (paramCount = 1)
                        call @callName(retval, params<1>)
                    case (paramCount = 2)
                        call @callName(retval, params<1>, params<2>)
                    case (paramCount = 3)
                        call @callName(retval, params<1>, params<2>, params<3>)
                    case (paramCount = 4)
                        call @callName(retval, params<1>, params<2>, params<3>, params<4>)
                    case (paramCount = 5)
                        call @callName(retval, params<1>, params<2>, params<3>, params<4>, params<5>)
                end case
                call assertEqual(expected, retval)
            end
            lPasses += 1
            crt "Passed!"
        
        catch Ignore
            callName = test[':', 2, 1]
            lIgnores += 1
            crt "Ignored!"
            
        catch Skip
            callName = test[':', 2, 1]
            lSkips += 1
            crt "Skipped!"
        
        catch AssertionError
            lFailures += 1
            crt "Failed!"
            crt @EXCEPTION : " -> " : @EXCEPTION.DATA
        
        catch SYS$ANY
            lErrors += 1
            crt "Error! (" : @EXCEPTION : ")"
            crt @EXCEPTION.DATA
            
        end
        crt callName : ": " :
        crt lPasses : " passes/ " :
        crt lFailures : " failures/ " :
        crt lErrors : " errors/ " :
        crt lIgnores : " ignored/ " :
        crt lSkips : " skipped"
        crt
        passes += lPasses
        failures += lFailures
        errors += lErrors
        ignores += lIgnores
        skips += lSkips
    end
    
    public sub parseAnnotations(className)
        call !findprog(result, className)
        annotations = result<4>
        ignoreNext = @false
        skipNext = @false
        testCount = 0
        for each annotation in annotations
            uAnnotation = upcase(annotation)
            begin case
                case (uAnnotation matches "0X'@BEFORECLASS'0X")
                    beforeClass = annotation[':', 2, 1] 
                case (uAnnotation matches "0X'@AFTERCLASS'0X")
                    afterClass = annotation[':', 2, 1]
                case (uAnnotation matches "0X'@BEFORE'0X")
                    beforeMethod = annotation[':', 2, 1]
                case (uAnnotation matches "0X'@AFTER'0X")
                    afterMethod = annotation[':', 2, 1]
                case (uAnnotation matches "0X'@EXPECTEDEXCEPTION'0X")
                    exceptions = insert(exceptions, testCount+1; annotation['=', 2, 1])
                case (uAnnotation matches "0X'@IGNORE'0X")
                    ignoreNext = @true
                case (uAnnotation matches "0X'@SKIP'0X")
                    skipNext = @true
                case (uAnnotation matches "0X'@TEST'0X")
                    tests = insert(tests, testCount+1; annotation[':', 2, *])
                    ignored = insert(ignored, testCount+1; ignoreNext)
                    skipped = insert(skipped, testCount+1; skipNext)
                    ignoreNext = @false
                    skipNext = @false
                    testCount += 1
            end case
        next annotation
    end
    
    get getPasses()
        return passes
    end
    
    get getFailures()
        return failures
    end
    
    get getErrors()
        return errors
    end
    
    get getIgnores()
        return ignores
    end
    
    get getSkips()
        return skips
    end

end
