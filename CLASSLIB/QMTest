$catalog QMTest global
class QMTest

    shared private passes, failures, errors, ignores, skips
    private lPasses, lFailures, lErrors, lIgnores, lSkips, ignore, skip
    
    public sub create.object()
        if unassigned(passes) then passes = 0
        if unassigned(failures) then failures = 0
        if unassigned(errors) then errors = 0
        if unassigned(ignores) then ignores = 0
        if unassigned(skips) then skips = 0
        lPasses = 0
        lFailures = 0
        lErrors = 0
        lIgnores = 0
        lSkips = 0
        ignore = @false
        skip = @false
    end
    
    public sub run(className, obj)
        try
            call !findprog(result, className)
            annotations = result<4>
            
            *
            * Check for @BeforeClass annotation and run once before
            * all the test methods are run.
            *
            bcpos = index(annotations, "@BeforeClass", 1)
            if (bcpos > 0) then
                bcanno = annotations[bcpos, *]<1,1>
                method = bcanno[':', 2, 1]
                obj->(method)()
            end

            *
            * Check for @Before annotation and setup the beforeMethod
            * variable to be run before each test is run.
            *
            beforeMethod = ''
            bpos = index(annotations, "@Before:", 1)
            if (bpos > 0) then
                banno = annotations[bpos, *]<1,1>
                beforeMethod = banno[':', 2, 1]
            end  

            *
            * Check for @After annotation and setup the afterMethod
            * variable to be run after each test is run.
            *   
            afterMethod = ''         
            apos = index(annotations, "@After:", 1)
            if (apos > 0) then
                aanno = annotations[apos, *]<1,1>
                afterMethod = aanno[':', 2, 1]
                crt afterMethod
            end
                              
            *
            * Loop through the annotations looking for @Test
            * annotations, run the beforeMethod (if one defined),
            * run the test method, the run the afterMethod (if one
            * defined).  Wrap the test method itself in a try/
            * catch block to catch assertions that fail.  Allow all
            * non-assertion errors to be logged as errors and 
            * end the run of this test class.
            * 
            for each annotation in annotations
                begin case
                    case (annotation[1,6] = "@Test:")
                        method = annotation[':', 2, 1]
                        crt className : ":" : method : " -> " :
                        if (ignore) then
                            ignore = @false
                            lIgnores += 1
                            crt "Ignored!"
                            continue
                        end
                        if (skip) then
                            skip = @false
                            lSkips += 1
                            crt "Skipped!"
                            continue
                        end
                        if (beforeMethod # '') then obj->(beforeMethod)()
                        try
                            obj->(method)()
                            lPasses += 1
                            crt "Passed!"
                            if (afterMethod # '') then obj->(afterMethod)()
                        catch AssertionError
                            lFailures += 1
                            crt "Failed!"
                            crt @EXCEPTION : " -> " : @EXCEPTION.DATA
                        end
                    case (annotation[1,7] = "@Ignore")
                        ignore = @true
                    case (annotation[1,5] = "@Skip")
                        skip = @true
                end case
            next annotation
            
            *
            * Check for @AfterClass annotation and run once after
            * all tests have completed.
            *
            acpos = index(annotations, "@AfterClass", 1)
            if (acpos > 0) then
                acanno = annotations[acpos, *]<1,1>
                method = acanno[':', 2, 1]
                obj->(method)()
            end
            
        catch SYS$ANY
            lErrors += 1
            crt "Error! (" : @EXCEPTION : ")"
            crt @EXCEPTION.DATA
            
        end
        crt className : ": " :
        crt lPasses : " passes/ " :
        crt lFailures : " failures/ " :
        crt lErrors : " errors/ " :
        crt lIgnores : " ignored/ " :
        crt lSkips : " skipped"
        crt
        passes += lPasses
        failures += lFailures
        errors += lErrors
        ignores += lIgnores
        skips += lSkips
    end
    
    public sub runSub(subName)
        
        try
            crt subName : ": " :
            call !findprog(result, subName)
            annotation = result<4>
            if (annotation<1,1> = "@Ignore") then throw "Ignore"
            if (annotation<1,1> = "@Skip") then throw "Skip"
            *
            * @Test:subName:sub/func:param1,param2,...:expected
            *
            * subName is the name of the subroutine/function as cataloged
            * sub/func is the type of call (subroutine or function)
            * param1... are the actual test parameter values to be used
            * expected is the result return if type if func[tion]
            *
            callName = annotation[':', 2, 1]
            callType = annotation[':', 3, 1]
            callParams = annotation[':', 4, 1]
            expected = annotation[':', 5, 1]
            paramCount = dcount(callParams, ',')
            params = ''
            for p = 1 to paramCount
                params<p> = callParams[',', p, 1]
            next p
            if (callType[1,3] = "sub") then
                begin case
                    CASE (paramCount = 0)
                        call @callName
                    case (paramCount = 1)
                        call @callName(params<1>)
                    case (paramCount = 2)
                        call @callName(params<1>, params<2>)
                    case (paramCount = 3)
                        call @callName(params<1>, params<2>, params<3>)
                    case (paramCount = 4)
                        call @callName(params<1>, params<2>, params<3>, params<4>)
                    case (paramCount = 5)
                        call @callName(params<1>, params<2>, params<3>, params<4>, params<5>)
                end case
            end else
                begin case
                    case (paramCount = 0)
                        call @callName(retval)
                    case (paramCount = 1)
                        call @callName(retval, params<1>)
                    case (paramCount = 2)
                        call @callName(retval, params<1>, params<2>)
                    case (paramCount = 3)
                        call @callName(retval, params<1>, params<2>, params<3>)
                    case (paramCount = 4)
                        call @callName(retval, params<1>, params<2>, params<3>, params<4>)
                    case (paramCount = 5)
                        call @callName(retval, params<1>, params<2>, params<3>, params<4>, params<5>)
                end case
                call assertEqual(expected, retval)
            end
            lPasses += 1
            crt "Passed!"
        
        catch Ignore
            callName = annotation<1,2>[':', 2, 1]
            lIgnores += 1
            crt "Ignored!"
            
        catch Skip
            callName = annotation<1,2>[':', 2, 1]
            lSkips += 1
            crt "Skipped!"
        
        catch AssertionError
            lFailures += 1
            crt "Failed!"
            crt @EXCEPTION : " -> " : @EXCEPTION.DATA
        
        catch SYS$ANY
            lErrors += 1
            crt "Error! (" : @EXCEPTION : ")"
            crt @EXCEPTION.DATA
             
        end
        crt callName : ": " :
        crt lPasses : " passes/ " :
        crt lFailures : " failures/ " :
        crt lErrors : " errors/ " :
        crt lIgnores : " ignored/ " :
        crt lSkips : " skipped"
        crt
        passes += lPasses
        failures += lFailures
        errors += lErrors
        ignores += lIgnores
        skips += lSkips
    end
    
    get getPasses()
        return passes
    end
    
    get getFailures()
        return failures
    end
    
    get getErrors()
        return errors
    end
    
    get getIgnores()
        return ignores
    end
    
    get getSkips()
        return skips
    end

end
